# [二叉树的深度](https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&tqId=11191&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

### 方法一

递归

```c++
class Solution {
public:
    int TreeDepth(TreeNode* pRoot){
        if(!pRoot)
            return 0;
        return 1 + max(TreeDepth(pRoot->left), TreeDepth(pRoot->right));
    }
};
```



### 方法二

非递归

```c++
class Solution {
public:
    int TreeDepth(TreeNode* pRoot){
        if(!pRoot)
            return 0;
        queue<TreeNode*> q;
        q.push(pRoot);
        int depth = 0;
        while(!q.empty()){
            depth++;
            for(int i = 0; i < q.size(); i++){
                TreeNode* node = q.front();
                q.pop();
                if(node->left)
                    q.push(node->left);
                if(node->right)
                    q.push(node->right);
            }
        }
        return depth;
    }
};
```



