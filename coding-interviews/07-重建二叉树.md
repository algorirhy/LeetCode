# [重建二叉树](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

### 方法一

递归

#### C++

```C++
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int len = inorder.size();
        if(len == 0)
            return nullptr;
        vector<int> pre_left, pre_right, in_left, in_right;
        TreeNode* head = new TreeNode(preorder[0]);
        int pos = 0;
        for(int i =0; i < len; i++){
            if(inorder[i] == preorder[0]){
                pos = i;
                break;
            }
        }
        for(int i = 0; i < pos; i++){
            in_left.push_back(inorder[i]);
            pre_left.push_back(preorder[i+1]);
        }
        for(int i = pos + 1; i < len; i++){
            in_right.push_back(inorder[i]);
            pre_right.push_back(preorder[i]);
        }
        head->left = buildTree(pre_left, in_left);
        head->right = buildTree(pre_right, in_right);
        return head;
    }
};
```

#### Java

```Java

```

