# [重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

#### C++

```C++
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int len = inorder.size();
        if(len == 0)
            return nullptr;
        vector<int> pre_left, pre_right, in_left, in_right;
        TreeNode* head = new TreeNode(preorder[0]);
        int pos = 0;
        for(int i =0; i < len; i++){
            if(inorder[i] == preorder[0]){
                pos = i;
                break;
            }
        }
        for(int i = 0; i < pos; i++){
            in_left.push_back(inorder[i]);
            pre_left.push_back(preorder[i+1]);
        }
        for(int i = pos + 1; i < len; i++){
            in_right.push_back(inorder[i]);
            pre_right.push_back(preorder[i]);
        }
        head->left = buildTree(pre_left, in_left);
        head->right = buildTree(pre_right, in_right);
        return head;
    }
};
```

#### Java

```Java
class Solution {
    
    HashMap<Integer, Integer> map = new HashMap<>();
    int[] preorder;

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        this.preorder = preorder;
        for (int i = 0; i < inorder.length; i++) {
            map.put(inorder[i], i);
        }
        return build(0, 0, preorder.length - 1);
    }

    // 根节点前序遍历对应的索引pre_root、中序遍历左边界in_left、中序遍历右边界in_right
    private TreeNode build(int pre_root, int in_left, int in_right) {
        if (in_left > in_right) {
            return null;
        }
        TreeNode root = new TreeNode(preorder[pre_root]);
        //根节点中序遍历对应的索引
        int index = map.get(preorder[pre_root]);
        root.left = build(pre_root + 1, in_left, index - 1);
        //根节点索引 + 左子树长度 + 1
        root.right = build(pre_root + index - in_left + 1, index + 1, in_right);
        return root;
    } 
}
```

