# [两个链表的第一个公共结点](https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&tqId=11189&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

### 方法一

相当于把两个链表拼起来

```c++
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        ListNode* p1 = pHead1;
        ListNode* p2 = pHead2;
        while(p1 != p2){
            p1 = (p1 == nullptr ? pHead2 : p1->next);
            p2 = (p2 == nullptr ? pHead1 : p2->next);
        }
        return p1;
    }
};
```



### 方法二

找出2个链表的长度，然后让长的先走两个链表的长度差，然后再一起走

```c++
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        if(!pHead1 || !pHead2)
            return nullptr;
        
        int len1 = findListLength(pHead1);
        int len2 = findListLength(pHead2);
        
        if(len1 < len2){
            pHead2 = walkKStep(pHead2, len2 - len1);
        }else if(len2 < len1){
            pHead1 = walkKStep(pHead1, len1 - len2);
        }
        
        while(pHead1 != pHead2){
            pHead1 = pHead1->next;
            pHead2 = pHead2->next;
        }
        return pHead1;
    }

    int findListLength(ListNode* list){
        int len = 0;
        while(list){
            list = list->next;
            len++;
        }
        return len;
    }
    
    ListNode* walkKStep(ListNode* list, int k){
        while(k--)
            list = list->next;
        return list;
    }
};
```

