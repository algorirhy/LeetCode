# [反转链表](https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=11168&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

### 方法一

递归

```c++
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        if(pHead == nullptr || pHead->next == nullptr)
            return pHead;
        ListNode* new_head = ReverseList(pHead->next);
        // head->next 此时指向子链表的最后一个结点
        // 将之前的头结点放入子链尾
        pHead->next->next = pHead;
        pHead->next = nullptr;
        return new_head;
    }
};
```



### 方法二

非递归

```C++
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        if(pHead == nullptr || pHead->next == nullptr)
            return pHead;
        ListNode* p1 = pHead;
        ListNode* p2 = p1->next;
        ListNode* p3 = p2->next;
        while(p2){
            p3 = p2->next;
            p2->next = p1;
            p1 = p2;
            p2 = p3;
        }
        pHead->next = nullptr;
        pHead = p1;
        return p1;
    }
};
```



参考资料：[LeetCode 206——反转链表](https://www.jianshu.com/p/f7534f8d7bf2)

